<?xml version="1.0"?>
<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->


<!DOCTYPE page [
<!ENTITY % extensionsDTD SYSTEM "chrome://mozapps/locale/extensions/extensions.dtd">
%extensionsDTD;
]>

<!-- import-globals-from extensions.js -->

<bindings id="addonBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">


  <!-- Addon - generic - A normal addon item, or an update to one -->
  <binding id="addon-generic"
           extends="chrome://mozapps/content/extensions/extensions.xml#addon-base">
    <content>
      <xul:hbox anonid="warning-container"
                class="warning">
        <xul:image class="warning-icon"/>
        <xul:label anonid="warning" flex="1"/>
        <xul:label anonid="warning-link" class="text-link"/>
        <xul:button anonid="warning-btn" class="button-link" hidden="true"/>
        <xul:spacer flex="5000"/> <!-- Necessary to allow the message to wrap -->
      </xul:hbox>
      <xul:hbox anonid="error-container"
                class="error">
        <xul:image class="error-icon"/>
        <xul:label anonid="error" flex="1"/>
        <xul:label anonid="error-link" class="text-link" hidden="true"/>
        <xul:spacer flex="5000"/> <!-- Necessary to allow the message to wrap -->
      </xul:hbox>
      <xul:hbox anonid="pending-container"
                class="pending">
        <xul:image class="pending-icon"/>
        <xul:label anonid="pending" flex="1"/>
        <xul:button anonid="restart-btn" class="button-link"
                    label="&addon.restartNow.label;"
                    oncommand="document.getBindingParent(this).restart();"/>
        <xul:button anonid="undo-btn" class="button-link"
                    label="&addon.undoAction.label;"
                    tooltipText="&addon.undoAction.tooltip;"
                    oncommand="document.getBindingParent(this).undo();"/>
        <xul:spacer flex="5000"/> <!-- Necessary to allow the message to wrap -->
      </xul:hbox>

      <xul:hbox class="content-container" align="center">
        <xul:vbox class="icon-container">
          <xul:image anonid="icon" class="icon"/>
        </xul:vbox>
        <xul:vbox class="content-inner-container" flex="1">
          <xul:hbox class="basicinfo-container">
              <xul:hbox class="name-container">
                <xul:label anonid="name" class="name" crop="end" flex="1"
                           tooltip="addonitem-tooltip" xbl:inherits="value=name,tooltiptext=name"/>
				<xul:label anonid="version" class="version"/>
                <xul:label anonid="legacy" class="legacy-warning text-link" value="&addon.legacy.label;"/>
                <xul:label class="disabled-postfix" value="&addon.disabled.postfix;"/>
                <xul:label class="update-postfix" value="&addon.update.postfix;"/>
                <xul:spacer flex="5000"/> <!-- Necessary to make the name crop -->
              </xul:hbox>
            <xul:label anonid="date-updated" class="date-updated"
                       unknown="&addon.unknownDate;"/>
          </xul:hbox>
          <xul:hbox class="experiment-container">
            <svg width="6" height="6" viewBox="0 0 6 6" version="1.1"
                 xmlns="http://www.w3.org/2000/svg"
                 class="experiment-bullet-container">
              <circle cx="3" cy="3" r="3" class="experiment-bullet"/>
            </svg>
            <xul:label anonid="experiment-state" class="experiment-state"/>
            <xul:label anonid="experiment-time" class="experiment-time"/>
          </xul:hbox>

          <xul:hbox class="advancedinfo-container" flex="1">
            <xul:vbox class="description-outer-container" flex="1">
              <xul:hbox class="description-container">
                <xul:label anonid="description" class="description" crop="end" flex="1"/>
                <xul:button anonid="details-btn" class="details button-link"
                            label="&addon.details.label;"
                            tooltiptext="&addon.details.tooltip;"
                            oncommand="document.getBindingParent(this).showInDetailView();"/>
                <xul:spacer flex="5000"/> <!-- Necessary to make the description crop -->
              </xul:hbox>
              <xul:vbox anonid="relnotes-container" class="relnotes-container">
                <xul:label class="relnotes-header" value="&addon.releaseNotes.label;"/>
                <xul:label anonid="relnotes-loading" value="&addon.loadingReleaseNotes.label;"/>
                <xul:label anonid="relnotes-error" hidden="true"
                           value="&addon.errorLoadingReleaseNotes.label;"/>
                <xul:vbox anonid="relnotes" class="relnotes"/>
              </xul:vbox>
              <xul:hbox class="relnotes-toggle-container">
                <xul:button anonid="relnotes-toggle-btn" class="relnotes-toggle"
                            hidden="true" label="&cmd.showReleaseNotes.label;"
                            tooltiptext="&cmd.showReleaseNotes.tooltip;"
                            showlabel="&cmd.showReleaseNotes.label;"
                            showtooltip="&cmd.showReleaseNotes.tooltip;"
                            hidelabel="&cmd.hideReleaseNotes.label;"
                            hidetooltip="&cmd.hideReleaseNotes.tooltip;"
                            oncommand="document.getBindingParent(this).toggleReleaseNotes();"/>
              </xul:hbox>
            </xul:vbox>
          </xul:hbox>
        </xul:vbox>
        <xul:vbox class="status-control-wrapper">
          <xul:hbox class="status-container">
            <xul:hbox anonid="checking-update" hidden="true">
              <xul:image class="spinner"/>
              <xul:label value="&addon.checkingForUpdates.label;"/>
            </xul:hbox>
            <xul:vbox anonid="update-available" class="update-available"
                      hidden="true">
              <xul:checkbox anonid="include-update" class="include-update"
                            label="&addon.includeUpdate.label;" checked="true"
                            oncommand="document.getBindingParent(this).onIncludeUpdateChanged();"/>
              <xul:hbox class="update-info-container">
                <xul:label class="update-available-notice"
                           value="&addon.updateAvailable.label;"/>
                <xul:button anonid="update-btn" class="addon-control update"
                            label="&addon.updateNow.label;"
                            tooltiptext="&addon.updateNow.tooltip;"
                            oncommand="document.getBindingParent(this).upgrade();"/>
              </xul:hbox>
            </xul:vbox>
            <xul:hbox anonid="install-status" class="install-status"
                      hidden="true"/>
          </xul:hbox>
          <xul:hbox anonid="control-container" class="control-container">
            <xul:button anonid="preferences-btn"
                        class="addon-control preferences"
                        label="&cmd.showPreferencesWin.label;"
                        tooltiptext="&cmd.showPreferencesWin.tooltip;"
                        oncommand="document.getBindingParent(this).showPreferences();"/>
            <xul:button anonid="enable-btn"  class="addon-control enable"
                        label="&cmd.enableAddon.label;"
                        oncommand="document.getBindingParent(this).userDisabled = false;"/>
            <xul:button anonid="disable-btn" class="addon-control disable"
                        label="&cmd.disableAddon.label;"
                        oncommand="document.getBindingParent(this).userDisabled = true;"/>
            <xul:button anonid="replacement-btn" class="addon-control replacement"
                        label="&cmd.findReplacement.label;"
                        oncommand="document.getBindingParent(this).findReplacement();"/>
            <xul:button anonid="remove-btn" class="addon-control remove"
                        label="&cmd.uninstallAddon.label;"
                        oncommand="document.getBindingParent(this).uninstall();"/>
            <xul:menulist anonid="state-menulist"
                          class="addon-control state"
                          tooltiptext="&cmd.stateMenu.tooltip;">
              <xul:menupopup>
                <xul:menuitem anonid="ask-to-activate-menuitem"
                              class="addon-control"
                              label="&cmd.askToActivate.label;"
                              tooltiptext="&cmd.askToActivate.tooltip;"
                              oncommand="document.getBindingParent(this).userDisabled = AddonManager.STATE_ASK_TO_ACTIVATE;"/>
                <xul:menuitem anonid="always-activate-menuitem"
                              class="addon-control"
                              label="&cmd.alwaysActivate.label;"
                              tooltiptext="&cmd.alwaysActivate.tooltip;"
                              oncommand="document.getBindingParent(this).userDisabled = false;"/>
                <xul:menuitem anonid="never-activate-menuitem"
                              class="addon-control"
                              label="&cmd.neverActivate.label;"
                              tooltiptext="&cmd.neverActivate.tooltip;"
                              oncommand="document.getBindingParent(this).userDisabled = true;"/>
              </xul:menupopup>
            </xul:menulist>
          </xul:hbox>
        </xul:vbox>
      </xul:hbox>
    </content>

    <implementation>
      <constructor><![CDATA[
        this._installStatus = document.getAnonymousElementByAttribute(this, "anonid", "install-status");
        this._installStatus.mControl = this;

        this.setAttribute("contextmenu", "addonitem-popup");

        this._showStatus("none");

        this._initWithAddon(this.mAddon);

        gEventManager.registerAddonListener(this, this.mAddon.id);
      ]]></constructor>

      <destructor><![CDATA[
        gEventManager.unregisterAddonListener(this, this.mAddon.id);
      ]]></destructor>

      <field name="_warningContainer">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "warning-container");
      </field>
      <field name="_warning">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "warning");
      </field>
      <field name="_warningLink">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "warning-link");
      </field>
      <field name="_warningBtn">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "warning-btn");
      </field>
      <field name="_errorContainer">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "error-container");
      </field>
      <field name="_error">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "error");
      </field>
      <field name="_errorLink">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "error-link");
      </field>
      <field name="_pendingContainer">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "pending-container");
      </field>
      <field name="_pending">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "pending");
      </field>
      <field name="_infoContainer">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "info-container");
      </field>
      <field name="_info">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "info");
      </field>
      <field name="_version">
        document.getAnonymousElementByAttribute(this, "anonid", "version");
      </field>
      <field name="_experimentState">
        document.getAnonymousElementByAttribute(this, "anonid", "experiment-state");
      </field>
      <field name="_experimentTime">
        document.getAnonymousElementByAttribute(this, "anonid", "experiment-time");
      </field>
      <field name="_icon">
        document.getAnonymousElementByAttribute(this, "anonid", "icon");
      </field>
      <field name="_dateUpdated">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "date-updated");
      </field>
      <field name="_description">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "description");
      </field>
      <field name="_stateMenulist">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "state-menulist");
      </field>
      <field name="_askToActivateMenuitem">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "ask-to-activate-menuitem");
      </field>
      <field name="_alwaysActivateMenuitem">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "always-activate-menuitem");
      </field>
      <field name="_neverActivateMenuitem">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "never-activate-menuitem");
      </field>
      <field name="_preferencesBtn">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "preferences-btn");
      </field>
      <field name="_enableBtn">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "enable-btn");
      </field>
      <field name="_disableBtn">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "disable-btn");
      </field>
      <field name="_removeBtn">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "remove-btn");
      </field>
      <field name="_updateBtn">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "update-btn");
      </field>
      <field name="_controlContainer">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "control-container");
      </field>
      <field name="_installStatus">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "install-status");
      </field>
      <field name="_checkingUpdate">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "checking-update");
      </field>
      <field name="_updateAvailable">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "update-available");
      </field>
      <field name="_includeUpdate">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "include-update");
      </field>
      <field name="_relNotesLoaded">false</field>
      <field name="_relNotesToggle">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "relnotes-toggle-btn");
      </field>
      <field name="_relNotesLoading">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "relnotes-loading");
      </field>
      <field name="_relNotesError">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "relnotes-error");
      </field>
      <field name="_relNotesContainer">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "relnotes-container");
      </field>
      <field name="_relNotes">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "relnotes");
      </field>

      <property name="userDisabled">
        <getter><![CDATA[
          return this.mAddon.userDisabled;
        ]]></getter>
        <setter><![CDATA[
          if (val === true) {
            gViewController.commands.cmd_disableItem.doCommand(this.mAddon);
          } else if (val === false) {
            gViewController.commands.cmd_enableItem.doCommand(this.mAddon);
          } else {
            this.mAddon.userDisabled = val;
          }
        ]]></setter>
      </property>

      <property name="includeUpdate">
        <getter><![CDATA[
          return this._includeUpdate.checked && !!this.mManualUpdate;
        ]]></getter>
        <setter><![CDATA[
          // XXXunf Eventually, we'll want to persist this for individual
          //        updates - see bug 594619.
          this._includeUpdate.checked = !!val;
        ]]></setter>
      </property>

      <method name="_initWithAddon">
        <parameter name="aAddon"/>
        <body><![CDATA[
          this.mAddon = aAddon;

          this._installStatus.mAddon = this.mAddon;
          this._updateDates();
          this._updateState();

          this.setAttribute("name", aAddon.name);

          var iconURL = AddonManager.getPreferredIconURL(aAddon, 48, window);
          if (iconURL)
            this._icon.src = iconURL;
          else
            this._icon.src = "";

		  if (shouldShowVersionNumber(this.mAddon))
            this._version.value = this.mAddon.version;
          else
            this._version.hidden = true;
          if (this.mAddon.description)
            this._description.value = this.mAddon.description;
          else
            this._description.hidden = true;

          let legacyWarning = legacyExtensionsEnabled && !this.mAddon.install &&
            isLegacyExtension(this.mAddon);
          this.setAttribute("legacy", legacyWarning);
          document.getAnonymousElementByAttribute(this, "anonid", "legacy").href = SUPPORT_URL + "webextensions";

          if (!("applyBackgroundUpdates" in this.mAddon) ||
              (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DISABLE ||
               (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DEFAULT &&
                !AddonManager.autoUpdateDefault))) {
            AddonManager.getAllInstalls(aInstallsList => {
              // This can return after the binding has been destroyed,
              // so try to detect that and return early
              if (!("onNewInstall" in this))
                return;
              for (let install of aInstallsList) {
                if (install.existingAddon &&
                    install.existingAddon.id == this.mAddon.id &&
                    install.state == AddonManager.STATE_AVAILABLE) {
                  this.onNewInstall(install);
                  this.onIncludeUpdateChanged();
                }
              }
            });
          }
        ]]></body>
      </method>

      <method name="_showStatus">
        <parameter name="aType"/>
        <body><![CDATA[
          this._controlContainer.hidden = aType != "none" &&
                                          !(aType == "update-available" && !this.hasAttribute("upgrade"));

          this._installStatus.hidden = aType != "progress";
          if (aType == "progress")
            this._installStatus.refreshState();
          this._checkingUpdate.hidden = aType != "checking-update";
          this._updateAvailable.hidden = aType != "update-available";
          this._relNotesToggle.hidden = !(this.mManualUpdate ?
                                          this.mManualUpdate.releaseNotesURI :
                                          this.mAddon.releaseNotesURI);
        ]]></body>
      </method>

      <method name="_updateDates">
        <body><![CDATA[
          function formatDate(aDate) {
            const dtOptions = { year: "numeric", month: "long", day: "numeric" };
            return aDate.toLocaleDateString(undefined, dtOptions);
          }

          if (this.mAddon.updateDate)
            this._dateUpdated.value = formatDate(this.mAddon.updateDate);
          else
            this._dateUpdated.value = this._dateUpdated.getAttribute("unknown");
        ]]></body>
      </method>

      <method name="_updateState">
        <body><![CDATA[
          if (this.parentNode.selectedItem == this)
            gViewController.updateCommands();

          var pending = this.mAddon.pendingOperations;
          if (pending != AddonManager.PENDING_NONE) {
            this.removeAttribute("notification");

            pending = null;
            const PENDING_OPERATIONS = ["enable", "disable", "install",
                                        "uninstall", "upgrade"];
            for (let op of PENDING_OPERATIONS) {
              if (this.isPending(op))
                pending = op;
            }

            this.setAttribute("pending", pending);
            this._pending.textContent = gStrings.ext.formatStringFromName(
              "notification." + pending,
              [this.mAddon.name, gStrings.brandShortName], 2
            );
          } else {
            this.removeAttribute("pending");

            var isUpgrade = this.hasAttribute("upgrade");
            var install = this._installStatus.mInstall;

            if (install && install.state == AddonManager.STATE_DOWNLOAD_FAILED) {
              this.setAttribute("notification", "warning");
              this._warning.textContent = gStrings.ext.formatStringFromName(
                "notification.downloadError",
                [this.mAddon.name], 1
              );
              this._warningBtn.label = gStrings.ext.GetStringFromName("notification.downloadError.retry");
              this._warningBtn.tooltipText = gStrings.ext.GetStringFromName("notification.downloadError.retry.tooltip");
              this._warningBtn.setAttribute("oncommand", "document.getBindingParent(this).retryInstall();");
              this._warningBtn.hidden = false;
              this._warningLink.hidden = true;
            } else if (install && install.state == AddonManager.STATE_INSTALL_FAILED) {
              this.setAttribute("notification", "warning");
              this._warning.textContent = gStrings.ext.formatStringFromName(
                "notification.installError",
                [this.mAddon.name], 1
              );
              this._warningBtn.label = gStrings.ext.GetStringFromName("notification.installError.retry");
              this._warningBtn.tooltipText = gStrings.ext.GetStringFromName("notification.downloadError.retry.tooltip");
              this._warningBtn.setAttribute("oncommand", "document.getBindingParent(this).retryInstall();");
              this._warningBtn.hidden = false;
              this._warningLink.hidden = true;
            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_BLOCKED) {
              this.setAttribute("notification", "error");
              this._error.textContent = gStrings.ext.formatStringFromName(
                "notification.blocked",
                [this.mAddon.name], 1
              );
              this._errorLink.value = gStrings.ext.GetStringFromName("notification.blocked.link");
              this._errorLink.href = this.mAddon.blocklistURL;
              this._errorLink.hidden = false;
            } else if (!isUpgrade && !isCorrectlySigned(this.mAddon) &&
                       AddonSettings.REQUIRE_SIGNING) {
              this.setAttribute("notification", "error");
              this._error.textContent = gStrings.ext.formatStringFromName(
                "notification.unsignedAndDisabled", [this.mAddon.name, gStrings.brandShortName], 2
              );
              this._errorLink.value = gStrings.ext.GetStringFromName("notification.unsigned.link");
              this._errorLink.href = SUPPORT_URL + "unsigned-addons";
              this._errorLink.hidden = false;
            } else if ((!isUpgrade && !this.mAddon.isCompatible) && (AddonManager.checkCompatibility
            || (this.mAddon.blocklistState != Ci.nsIBlocklistService.STATE_SOFTBLOCKED))) {
              this.setAttribute("notification", "warning");
              this._warning.textContent = gStrings.ext.formatStringFromName(
                "notification.incompatible",
                [this.mAddon.name, gStrings.brandShortName, gStrings.appVersion], 3
              );
              this._warningLink.hidden = true;
              this._warningBtn.hidden = true;
            } else if (!isUpgrade && this.mAddon.appDisabled &&
                       !this.mAddon.multiprocessCompatible &&
                       !Services.prefs.getBoolPref("extensions.allow-non-mpc-extensions", true)) {
              this.setAttribute("notification", "error");
              this._error.textContent = gStrings.ext.formatStringFromName(
                "notification.nonMpcDisabled", [this.mAddon.name], 1
              );
              this._errorLink.value = gStrings.ext.GetStringFromName("notification.nonMpcDisabled.link");
              this._errorLink.href = "https://wiki.mozilla.org/Add-ons/ShimsNightly";
              this._errorLink.hidden = false;
            } else if (!isUpgrade && !isCorrectlySigned(this.mAddon)) {
              this.setAttribute("notification", "warning");
              this._warning.textContent = gStrings.ext.formatStringFromName(
                "notification.unsigned", [this.mAddon.name, gStrings.brandShortName], 2
              );
              this._warningLink.value = gStrings.ext.GetStringFromName("notification.unsigned.link");
              this._warningLink.href = SUPPORT_URL + "unsigned-addons";
              this._warningLink.hidden = false;
            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_SOFTBLOCKED) {
              this.setAttribute("notification", "warning");
              this._warning.textContent = gStrings.ext.formatStringFromName(
                "notification.softblocked",
                [this.mAddon.name], 1
              );
              this._warningLink.value = gStrings.ext.GetStringFromName("notification.softblocked.link");
              this._warningLink.href = this.mAddon.blocklistURL;
              this._warningLink.hidden = false;
              this._warningBtn.hidden = true;
            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_OUTDATED) {
              this.setAttribute("notification", "warning");
              this._warning.textContent = gStrings.ext.formatStringFromName(
                "notification.outdated",
                [this.mAddon.name], 1
              );
              this._warningLink.value = gStrings.ext.GetStringFromName("notification.outdated.link");
              this._warningLink.href = this.mAddon.blocklistURL;
              this._warningLink.hidden = false;
              this._warningBtn.hidden = true;
            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_VULNERABLE_UPDATE_AVAILABLE) {
              this.setAttribute("notification", "error");
              this._error.textContent = gStrings.ext.formatStringFromName(
                "notification.vulnerableUpdatable",
                [this.mAddon.name], 1
              );
              this._errorLink.value = gStrings.ext.GetStringFromName("notification.vulnerableUpdatable.link");
              this._errorLink.href = this.mAddon.blocklistURL;
              this._errorLink.hidden = false;
            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_VULNERABLE_NO_UPDATE) {
              this.setAttribute("notification", "error");
              this._error.textContent = gStrings.ext.formatStringFromName(
                "notification.vulnerableNoUpdate",
                [this.mAddon.name], 1
              );
              this._errorLink.value = gStrings.ext.GetStringFromName("notification.vulnerableNoUpdate.link");
              this._errorLink.href = this.mAddon.blocklistURL;
              this._errorLink.hidden = false;
            } else if (this.mAddon.isGMPlugin && !this.mAddon.isInstalled &&
                       this.mAddon.isActive) {
              this.setAttribute("notification", "warning");
              this._warning.textContent =
                gStrings.ext.formatStringFromName("notification.gmpPending",
                                                  [this.mAddon.name], 1);
            } else {
              this.removeAttribute("notification");
            }
          }

          this._preferencesBtn.hidden = (!this.mAddon.optionsURL) ||
                                        this.mAddon.optionsType == AddonManager.OPTIONS_TYPE_INLINE_INFO;

          if (this.typeHasFlag("SUPPORTS_ASK_TO_ACTIVATE")) {
            this._enableBtn.disabled = true;
            this._disableBtn.disabled = true;
            this._askToActivateMenuitem.disabled = !this.hasPermission("ask_to_activate");
            this._alwaysActivateMenuitem.disabled = !this.hasPermission("enable");
            this._neverActivateMenuitem.disabled = !this.hasPermission("disable");
            if (!this.mAddon.isActive) {
              this._stateMenulist.selectedItem = this._neverActivateMenuitem;
            } else if (this.mAddon.userDisabled == AddonManager.STATE_ASK_TO_ACTIVATE) {
              this._stateMenulist.selectedItem = this._askToActivateMenuitem;
            } else {
              this._stateMenulist.selectedItem = this._alwaysActivateMenuitem;
            }
            let hasActivatePermission =
              ["ask_to_activate", "enable", "disable"].some(perm => this.hasPermission(perm));
            this._stateMenulist.disabled = !hasActivatePermission;
            this._stateMenulist.hidden = false;
            this._stateMenulist.classList.add("no-auto-hide");
          } else {
            this._stateMenulist.hidden = true;

            let enableTooltip = gViewController.commands.cmd_enableItem
                                               .getTooltip(this.mAddon);
            this._enableBtn.setAttribute("tooltiptext", enableTooltip);
            if (this.hasPermission("enable")) {
              this._enableBtn.hidden = false;
            } else {
              this._enableBtn.hidden = true;
            }

            let disableTooltip = gViewController.commands.cmd_disableItem
                                                .getTooltip(this.mAddon);
            this._disableBtn.setAttribute("tooltiptext", disableTooltip);
            if (this.hasPermission("disable")) {
              this._disableBtn.hidden = false;
            } else {
              this._disableBtn.hidden = true;
            }
          }

          let uninstallTooltip = gViewController.commands.cmd_uninstallItem
                                                .getTooltip(this.mAddon);
          this._removeBtn.setAttribute("tooltiptext", uninstallTooltip);
          if (this.hasPermission("uninstall")) {
            this._removeBtn.hidden = false;
          } else {
            this._removeBtn.hidden = true;
          }

          this.setAttribute("active", this.mAddon.isActive);

          var showProgress = this.mAddon.purchaseURL || (this.mAddon.install &&
                             this.mAddon.install.state != AddonManager.STATE_INSTALLED);
          this._showStatus(showProgress ? "progress" : "none");

          if (this.mAddon.type == "experiment") {
            this.removeAttribute("notification");
            let prefix = "experiment.";
            let active = this.mAddon.isActive;

            if (!showProgress) {
              let stateKey = prefix + "state." + (active ? "active" : "complete");
              this._experimentState.value = gStrings.ext.GetStringFromName(stateKey);

              let now = Date.now();
              let end = this.endDate;
              let days = Math.abs(end - now) / (24 * 60 * 60 * 1000);

              let timeKey = prefix + "time.";
              let timeMessage;

              if (days < 1) {
                timeKey += (active ? "endsToday" : "endedToday");
                timeMessage = gStrings.ext.GetStringFromName(timeKey);
              } else {
                timeKey += (active ? "daysRemaining" : "daysPassed");
                days = Math.round(days);
                let timeString = gStrings.ext.GetStringFromName(timeKey);
                timeMessage = PluralForm.get(days, timeString)
                                        .replace("#1", days);
              }

              this._experimentTime.value = timeMessage;
            }
          }
        ]]></body>
      </method>

      <method name="_fetchReleaseNotes">
        <parameter name="aURI"/>
        <body><![CDATA[
          if (!aURI || this._relNotesLoaded) {
            sendToggleEvent();
            return;
          }

          var relNotesData = null, transformData = null;

          this._relNotesLoaded = true;
          this._relNotesLoading.hidden = false;
          this._relNotesError.hidden = true;

          let sendToggleEvent = () => {
            var event = document.createEvent("Events");
            event.initEvent("RelNotesToggle", true, true);
            this.dispatchEvent(event);
          }

          let showRelNotes = () => {
            if (!relNotesData || !transformData)
              return;

            this._relNotesLoading.hidden = true;

            var processor = Components.classes["@mozilla.org/document-transformer;1?type=xslt"]
                                      .createInstance(Components.interfaces.nsIXSLTProcessor);
            processor.flags |= Components.interfaces.nsIXSLTProcessorPrivate.DISABLE_ALL_LOADS;

            processor.importStylesheet(transformData);
            var fragment = processor.transformToFragment(relNotesData, document);
            this._relNotes.appendChild(fragment);
            if (this.hasAttribute("show-relnotes")) {
              var container = this._relNotesContainer;
              container.style.height = container.scrollHeight + "px";
            }
            sendToggleEvent();
          }

          let handleError = () => {
            dataReq.abort();
            styleReq.abort();
            this._relNotesLoading.hidden = true;
            this._relNotesError.hidden = false;
            this._relNotesLoaded = false; // allow loading to be re-tried
            sendToggleEvent();
          }

          function handleResponse(aEvent) {
		  
		    var XMLURI_PARSE_ERROR = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
	
            var req = aEvent.target;
            var ct = req.getResponseHeader("content-type");
            if ((!ct || ct.indexOf("text/html") < 0) &&
                req.responseXML &&
                req.responseXML.documentElement.namespaceURI != XMLURI_PARSE_ERROR) {
              if (req == dataReq)
                relNotesData = req.responseXML;
              else
                transformData = req.responseXML;
              showRelNotes();
            } else {
              handleError();
            }
          }

          var dataReq = Components.classes["@mozilla.org/xmlextras/xmlhttprequest;1"]
                              .createInstance(Components.interfaces.nsIXMLHttpRequest);
          dataReq.open("GET", aURI.spec, true);
          dataReq.responseType = "document";
          dataReq.addEventListener("load", handleResponse);
          dataReq.addEventListener("error", handleError);
          dataReq.send(null);
		  
		  var UPDATES_RELEASENOTES_TRANSFORMFILE = "chrome://mozapps/content/extensions/updateinfo.xsl";

          var styleReq = Components.classes["@mozilla.org/xmlextras/xmlhttprequest;1"]
                              .createInstance(Components.interfaces.nsIXMLHttpRequest);
          styleReq.open("GET", UPDATES_RELEASENOTES_TRANSFORMFILE, true);
          styleReq.responseType = "document";
          styleReq.addEventListener("load", handleResponse);
          styleReq.addEventListener("error", handleError);
          styleReq.send(null);
        ]]></body>
      </method>

      <method name="toggleReleaseNotes">
        <body><![CDATA[
          if (this.hasAttribute("show-relnotes")) {
            this._relNotesContainer.style.height = "0px";
            this.removeAttribute("show-relnotes");
            this._relNotesToggle.setAttribute(
              "label",
              this._relNotesToggle.getAttribute("showlabel")
            );
            this._relNotesToggle.setAttribute(
              "tooltiptext",
              this._relNotesToggle.getAttribute("showtooltip")
            );
            var event = document.createEvent("Events");
            event.initEvent("RelNotesToggle", true, true);
            this.dispatchEvent(event);
          } else {
            this._relNotesContainer.style.height = this._relNotesContainer.scrollHeight +
                                                   "px";
            this.setAttribute("show-relnotes", true);
            this._relNotesToggle.setAttribute(
              "label",
              this._relNotesToggle.getAttribute("hidelabel")
            );
            this._relNotesToggle.setAttribute(
              "tooltiptext",
              this._relNotesToggle.getAttribute("hidetooltip")
            );
            var uri = this.mManualUpdate ?
                      this.mManualUpdate.releaseNotesURI :
                      this.mAddon.releaseNotesURI;
            this._fetchReleaseNotes(uri);
          }
        ]]></body>
      </method>

      <method name="restart">
        <body><![CDATA[
          gViewController.commands.cmd_restartApp.doCommand();
        ]]></body>
      </method>

      <method name="undo">
        <body><![CDATA[
          gViewController.commands.cmd_cancelOperation.doCommand(this.mAddon);
        ]]></body>
      </method>

      <method name="uninstall">
        <body><![CDATA[
          // If uninstalling does not require a restart and the type doesn't
          // support undoing of restartless uninstalls, then we fake it by
          // just disabling it it, and doing the real uninstall later.
          if (!this.opRequiresRestart("uninstall") &&
              !this.typeHasFlag("SUPPORTS_UNDO_RESTARTLESS_UNINSTALL")) {
            this.setAttribute("wasDisabled", this.mAddon.userDisabled);

            // We must set userDisabled to true first, this will call
            // _updateState which will clear any pending attribute set.
            this.mAddon.userDisabled = true;

            // This won't update any other add-on manager views (bug 582002)
            this.setAttribute("pending", "uninstall");
          } else {
            this.mAddon.uninstall(true);
          }
        ]]></body>
      </method>

      <method name="showPreferences">
        <body><![CDATA[
          gViewController.doCommand("cmd_showItemPreferences", this.mAddon);
        ]]></body>
      </method>

      <method name="upgrade">
        <body><![CDATA[
          var install = this.mManualUpdate;
          delete this.mManualUpdate;
          install.install();
        ]]></body>
      </method>

      <method name="retryInstall">
        <body><![CDATA[
          var install = this._installStatus.mInstall;
          if (!install)
            return;
          if (install.state != AddonManager.STATE_DOWNLOAD_FAILED &&
              install.state != AddonManager.STATE_INSTALL_FAILED)
            return;
          install.install();
        ]]></body>
      </method>

      <method name="showInDetailView">
        <body><![CDATA[
          gViewController.loadView("addons://detail/" +
                                   encodeURIComponent(this.mAddon.id));
        ]]></body>
      </method>

      <method name="findReplacement">
        <body><![CDATA[
          openURL(`https://addons.mozilla.org/find-replacement/?guid=${this.mAddon.id}`);
        ]]></body>
      </method>

      <method name="onIncludeUpdateChanged">
        <body><![CDATA[
          var event = document.createEvent("Events");
          event.initEvent("IncludeUpdateChanged", true, true);
          this.dispatchEvent(event);
        ]]></body>
      </method>

      <method name="onEnabling">
        <body><![CDATA[
          this._updateState();
        ]]></body>
      </method>

      <method name="onEnabled">
        <body><![CDATA[
          this._updateState();
        ]]></body>
      </method>

      <method name="onDisabling">
        <body><![CDATA[
          this._updateState();
        ]]></body>
      </method>

      <method name="onDisabled">
        <body><![CDATA[
          this._updateState();
        ]]></body>
      </method>

      <method name="onUninstalling">
        <parameter name="aRestartRequired"/>
        <body><![CDATA[
          this._updateState();
        ]]></body>
      </method>

      <method name="onOperationCancelled">
        <body><![CDATA[
          this._updateState();
        ]]></body>
      </method>

      <method name="onPropertyChanged">
        <parameter name="aProperties"/>
        <body><![CDATA[
          if (aProperties.indexOf("appDisabled") != -1 ||
              aProperties.indexOf("signedState") != -1 ||
              aProperties.indexOf("userDisabled") != -1)
            this._updateState();
        ]]></body>
      </method>

      <method name="onNoUpdateAvailable">
        <body><![CDATA[
          this._showStatus("none");
        ]]></body>
      </method>

      <method name="onCheckingUpdate">
        <body><![CDATA[
          this._showStatus("checking-update");
        ]]></body>
      </method>

      <method name="onCompatibilityUpdateAvailable">
        <body><![CDATA[
          this._updateState();
        ]]></body>
      </method>

      <method name="onExternalInstall">
        <parameter name="aAddon"/>
        <parameter name="aExistingAddon"/>
        <parameter name="aNeedsRestart"/>
        <body><![CDATA[
          if (aExistingAddon.id != this.mAddon.id)
            return;

          // If the install completed without needing a restart then switch to
          // using the new Addon
          if (!aNeedsRestart)
            this._initWithAddon(aAddon);
          else
            this._updateState();
        ]]></body>
      </method>

      <method name="onNewInstall">
        <parameter name="aInstall"/>
        <body><![CDATA[
          if (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_ENABLE)
            return;
          if (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DEFAULT &&
              AddonManager.autoUpdateDefault)
            return;

          this.mManualUpdate = aInstall;
          this._showStatus("update-available");
        ]]></body>
      </method>

      <method name="onDownloadStarted">
        <parameter name="aInstall"/>
        <body><![CDATA[
          this._updateState();
          this._showStatus("progress");
          this._installStatus.initWithInstall(aInstall);
        ]]></body>
      </method>

      <method name="onInstallStarted">
        <parameter name="aInstall"/>
        <body><![CDATA[
          this._updateState();
          this._showStatus("progress");
          this._installStatus.initWithInstall(aInstall);
        ]]></body>
      </method>

      <method name="onInstallEnded">
        <parameter name="aInstall"/>
        <parameter name="aAddon"/>
        <body><![CDATA[
          // If the install completed without needing a restart then switch to
          // using the new Addon
          if (!(aAddon.pendingOperations & AddonManager.PENDING_INSTALL))
            this._initWithAddon(aAddon);
          else
            this._updateState();
        ]]></body>
      </method>

      <method name="onDownloadFailed">
        <body><![CDATA[
            this._updateState();
        ]]></body>
      </method>

      <method name="onInstallFailed">
        <body><![CDATA[
            this._updateState();
        ]]></body>
      </method>

      <method name="onInstallCancelled">
        <body><![CDATA[
            this._updateState();
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="click" button="0"><![CDATA[
        switch (event.detail) {
        case 1:
          // Prevent double-click where the UI changes on the first click
          this._lastClickTarget = event.originalTarget;
          break;
        case 2:
          if (event.originalTarget.localName != "button" &&
              !event.originalTarget.classList.contains("text-link") &&
              event.originalTarget == this._lastClickTarget) {
            this.showInDetailView();
          }
          break;
        }
      ]]></handler>
    </handlers>
  </binding>

</bindings>
